/* eslint-disable office-addins/no-context-sync-in-loop */
/* global console, setTimeout, Office, document, Word, require */
import { create } from "zustand";
import formatTag from "@src/functions/formatTag";
import selectAndHightlightItem from "@src/functions/selectAndHightlightControl";
import resetControl from "@src/functions/resetControl";

export type id = number;
export type tag = string;
export type dataElement = {
  /**
   * Name/key of content, same as the visible text
   */
  tag: tag;
  /**
   * Unique identifier, generated by MS Word
   */
  id: id;
};

const TITLE = "DATA: " as const;
const debounceData = {
  renamingId: 0,
};

export type dataElementsStateType = {
  items: dataElement[];
  selectedId: id;
  itemIdsTracked: Record<string, boolean>;
  //
  loadAll: () => Promise<dataElement[]>;
  insertTag: (tag: tag) => dataElement | undefined;
  //
  renameId: (idToEdit: id, name: tag) => dataElement | undefined;
  renameTags: (tagToEdit: tag, name: tag) => dataElement | undefined;
  rename: (context: any, control: any, name: tag) => Promise<dataElement | undefined>;
  //
  deleteId: (id: id) => Promise<dataElement[]>;
  deleteTags: (tag: tag) => Promise<dataElement[]>;
  //
  selectTarget: (target: { ids: id[] }) => Promise<any>;
  clickTarget: (target: { ids: id[] }) => Promise<any>;
  selectId: (target: id) => Promise<any>;
};

const dataElementsState = create((set, get) => ({
  /**
   * All dataElements used in the template
   */
  items: [],
  itemIdsTracked: {},
  /**
   * Add a dataElement to the template, into the current cursor selection
   */
  insertTag: function (name: tag) {
    const that = get() as dataElementsStateType;
    return new Promise((resolve) => {
      // 1. Insert into document
      Word.run(async (context) => {
        const [tag] = formatTag(name, that.items);
        // parent
        const contentRange = context.document.getSelection();
        const contentControl = contentRange.insertContentControl();
        contentControl.title = TITLE;
        contentControl.tag = tag;
        resetControl(contentControl);
        contentControl.insertText(" ", "Replace");
        await context.sync();
        // child
        const contentControlRange = contentControl.getRange("Content");
        const contentControlChild = contentControlRange.insertContentControl();
        contentControlChild.tag = ":";
        contentControlChild.title = ":";
        resetControl(contentControlChild);
        contentControlChild.insertText(tag, "Replace");
        await context.sync();
        // control
        contentControlChild.cannotEdit = true;
        contentControl.cannotEdit = true;
        await context.sync();

        // 2. Move cursor outside of the new contentControl
        // insert space before
        const rangeBefore = contentControl.getRange("Before");
        rangeBefore.load(["text", "html", "getHtml"]);
        await context.sync();
        console.log(`text`, rangeBefore.text);
        await context.sync();
        rangeBefore.load("insertHtml");
        await context.sync();
        rangeBefore.insertHtml("&nbsp;", "Start");
        await context.sync();
        rangeBefore.select();
        // insert space after
        const rangeAfter = contentControl.getRange("After");
        rangeAfter.load("insertHtml");
        rangeAfter.load("text");
        await context.sync();
        console.log("rangeAfter", rangeAfter.text);
        await context.sync();
        const afterAdded = rangeAfter.insertHtml("&nbsp;", "End");
        await context.sync();
        afterAdded.select();

        // 3. Update app state
        const all = await that.loadAll();
        resolve(all);
      });
    });
  },
  /**
   * Rename tag of control
   */
  rename: async function (context: any, parentCC: Word.ContentControl, name: tag): Promise<any> {
    const that = get() as dataElementsStateType;
    const [tag, tagName, tagNum] = formatTag(name, that.items);
    parentCC.load(["id", "tag"]);
    await context.sync();
    if (tag === parentCC.tag || tagName === parentCC.tag || debounceData.renamingId === parentCC.id) {
      debounceData.renamingId = 0;
    } else {
      debounceData.renamingId = parentCC.id;
    }
    // modify inner ":" tag if nested inside container
    let childCC: Word.ContentControl = undefined;
    let parentRange = parentCC.getRange("Content");
    let childContentControls = parentRange.getContentControls();
    await context.sync();
    childContentControls.load("items");
    let item = childContentControls?.getFirstOrNullObject();
    await context.sync();
    item.load("isNullObject");
    await context.sync();
    if (item && !item.isNullObject) {
      item.load("title");
      await context.sync();
      if (item.title === ":") {
        console.log(["CHILD item found", item.title, item]);
        childCC = item;
      } else {
        console.log(["NOT child item", item.title, item]);
      }
    }
    // modify tags
    if (childCC) {
      // parent
      parentCC.cannotEdit = false;
      parentCC.load("tag");
      parentCC.tag = tag;
      // child
      childCC.cannotEdit = false;
      childCC.load("insertText");
      childCC.insertText(tag, "Replace");
      // sync
      childCC.cannotEdit = true;
      parentCC.cannotEdit = true;
      await context.sync();
    }
    return;
  },
  /**
   * Edit the item.tag name by Id
   */
  renameId: async function (idToEdit: id, name: tag): Promise<void> {
    const that = get() as dataElementsStateType;
    console.warn("dataElementsState.deleteTag()");
    return new Promise((resolve) => {
      Word.run(async (context) => {
        // 1. Edit tag name
        const contentControl = context.document.contentControls.getById(idToEdit);
        await that.rename(context, contentControl, name);
        // 2. Update state
        await that.loadAll();
        resolve();
      });
    });
  },
  /**
   * Edit the item.tag name by Tag (all matching instances)
   */
  renameTags: async function (tagToEdit: tag, name: tag): Promise<dataElement[]> {
    const that = get() as dataElementsStateType;
    console.warn("dataElementsState.deleteTag()");
    return new Promise((resolve) => {
      Word.run(async (context) => {
        // 1. Edit tag name
        const contentControls = context.document.contentControls.getByTag(tagToEdit);
        context.load(contentControls, "items");
        await context.sync();
        for (let item of contentControls.items) {
          await that.rename(context, item, name);
        }
        // 2. Update state
        const all = await that.loadAll();
        resolve(all);
      });
    });
  },

  deleteId: function (id: id): Promise<dataElement[]> {
    const that = get() as dataElementsStateType;
    console.warn("dataElementsState.deleteTag()");
    return new Promise((resolve) => {
      Word.run(async (context) => {
        const contentControl = context.document.contentControls.getById(id);
        // 1. Delete from document
        await context.sync();
        contentControl.load("delete");
        contentControl.cannotDelete = false;
        contentControl.delete(false);
        await context.sync();
        // 2. Update state
        const all = await that.loadAll();
        resolve(all);
      });
    });
  },

  deleteTags: function (tag: tag): Promise<dataElement[]> {
    const that = get() as dataElementsStateType;
    console.warn("dataElementsState.deleteTag()");
    return new Promise((resolve) => {
      Word.run(async (context) => {
        // 1. Delete from document
        const contentControls = context.document.contentControls.getByTag(tag);
        context.load(contentControls, "items");
        await context.sync();
        for (let item of contentControls.items) {
          item.load("delete");
          item.cannotDelete = false;
          item.delete(false);
        }
        await context.sync();
        // 2. Update state
        const all = await that.loadAll();
        resolve(all);
      });
    });
  },

  clickTarget: function (target: any) {
    const that = get() as dataElementsStateType;
    let id = typeof target === "number" ? target : target?.ids?.[0];
    // console.log("dataElements.clickTarget", id);
    if (!id) {
      console.error("no ids", target);
    }
    if (that.selectedId !== id) {
      set({ selectedId: id });
      that.selectId(id);
    }
  },

  selectTarget: function (target: any) {
    const that = get() as dataElementsStateType;
    let id = typeof target === "number" ? target : target?.ids?.[0];
    // console.log("dataElements.selectTarget", id);
    if (!id) {
      console.error("no ids", target);
    }
    if (that.selectedId !== id) {
      set({ selectedId: id });
      that.selectId(id);
    }
  },

  selectId: function (id: id) {
    console.log("dataElements.selectId", id);
    return new Promise((resolve) => {
      Word.run(async (context) => {
        let item = context.document.contentControls.getById(id);
        item.load("id");
        await context.sync();
        item.load("text");
        await context.sync();
        console.log(item.text);
        await selectAndHightlightItem(item, context);
        await context.sync();
        resolve(true);
      });
    });
  },

  /**
   * IMPORTANT! WARNING! It's OK for production, but good to know...
   * During development, "hot reloading", (get() as dataElementsStateType) runs again and again.
   * Each time, itemIdsTracked is reset to empty.
   * So, `item.onEntered` is added multiple times per content dataElement.
   */
  loadAll: function () {
    console.warn("dataElementsState.loadAll()");
    const that = get() as dataElementsStateType;
    const itemIdsTracked = that.itemIdsTracked || {};
    const itemIdsTrackedAdd = {};
    return new Promise((resolve) => {
      Word.run(async (context) => {
        // 1. Read document
        const contentControls = context.document.contentControls.getByTitle(TITLE);
        context.load(contentControls, "items");
        await context.sync();
        // 2. Update state
        const all = [];
        for (let item of contentControls.items) {
          item.load("onEntered");
          await context.sync();
          if (item.tag === ":") {
            continue;
          }
          if (!that.itemIdsTracked[item.id]) {
            resetControl(item);
            // console.log(["track item", item.text, item.id]);
            item.track();
            item.onEntered.add(that.clickTarget);
            item.onSelectionChanged.add(that.selectTarget);
            itemIdsTrackedAdd[item.id] = true;
            context.load(item);
          } else {
            // console.log(["already tracked", item.text, item.id]);
          }
          all.push({ id: item.id, tag: item.tag });
        }
        set({ items: all, itemIdsTracked: { ...itemIdsTracked, ...itemIdsTrackedAdd } });
        resolve(all);
      });
    });
  },
}));

export default dataElementsState;
